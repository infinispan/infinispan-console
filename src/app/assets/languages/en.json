{
  "brandname": {
    "brandname" : "Infinispan",
    "encoding-docs-link": "https://infinispan.org/docs/stable/titles/encoding/encoding.html",
    "persistence-docs-link": "https://infinispan.org/docs/stable/titles/configuring/configuring.html#persistence",
    "configuration-docs-link": "https://infinispan.org/docs/stable/titles/configuring/configuring.html"
  },
  "layout" : {
    "console-name": "Server Management Console",
    "skip-to-content": "Skip to Content",
    "about-name": "About"
    },
  "welcome-page" : {
    "description1": "{{brandname}} is an in-memory data store that offers scalability, interoperability, and fault tolerance.",
    "description2": "Use high-performance caching capabilities and create distributed data grids designed for microservice architectures.",
    "license": "Available under Apache License 2.0.",
    "connect" : "Connect to {{brandname}} clusters with remote clients.",
    "download" : "Download clients",
    "servers" :  "Install and configure {{brandname}} clusters.",
    "learn-more": "Get started",
    "develop": "Code applications for different use cases.",
    "tutorials":  "Run some quick tutorials",
    "go-to-console":  "Open the console"
  },
  "login-form": {
    "login-main": "Log in to {{brandname}}.",
    "login-label": "{{brandname}} login.",
    "login": "Log in",
    "cancel": "Cancel",
    "dialog-label": "{{brandname}} log in dialog.",
    "form-username": "Username",
    "help-username": "Enter your username.",
    "form-password": "Password",
    "help-password": "Enter your password."
  },
  "not-found-page" : {
    "title": "Page not found",
    "description": "That page no longer exists.",
    "button" : "Return to home page"
  },
  "support" : {
    "no-user": "Credentials required.",
    "no-user-text": "You must enter credentials to access the console. Create a username and password to continue.",
    "no-user-label": "No user credentials exist.",
    "reload-button" : "Reload",
    "text-create-user": "Create a username and password then reload.",
    "text-command": "bin/cli.sh user create myuser -p changeme -g admin"
  },
  "cache-managers" : {
    "title" : "Data container",
    "caches-tab" : "Caches",
    "counters-tab" : "Counters",
    "tasks-tab" : "Tasks",
    "schemas-tab" : "Schemas",
    "cache-table-label" : "Caches",
    "cache-name" : "Name",
    "cache-mode" : "Type",
    "cache-health" : "Health",
    "cache-features" : "Features",
    "cache-status" : "",
    "ignore" : "Hide",
    "undo-ignore" : "Show",
    "ignored-status" : "Hidden",
    "delete" : "Delete",
    "available": "Make available",
    "clear-all-button" : "Clear all",
    "no-caches-status" : "No caches yet",
    "no-caches-body" : "Select \"Create a cache\" and provide configuration in XML, JSON, or YAML format or use a custom template. You can also create caches from the CLI and remote clients.",
    "mode-local" : "Local",
    "mode-repl" : "Replicated",
    "mode-dist" : "Distributed",
    "mode-invalid" : "Invalidated",
    "mode-scattered" : "Scattered",
    "create-cache-button" : "Create a cache",
    "config-templates-button" : "Display cache templates",
    "cache-filter-label" : "Filter",
    "cache-filter-type-label" : "Cache type",
    "cache-filter-feature-label" : "Feature",
    "cache-filter-feature-bounded" : "Bounded",
    "cache-filter-feature-indexed" : "Indexed",
    "cache-filter-feature-persistent" : "Persistence",
    "cache-filter-feature-trans" : "Transactions",
    "cache-filter-feature-secure" : "Authorization",
    "cache-filter-feature-xsite" : "Backups",
    "cache-filter-feature-ignored" : "Hidden",
    "counters-table-label" : "Counters",
    "strong-counters" : "Strong counters",
    "weak-counters" : "Weak counters",
    "strong" : "Strong",
    "weak" : "Weak",
    "counter-name" : "Name",
    "current-value" : "Current value",
    "initial-value" : "Initial value",
    "lower-bound" : "Lower bound:",
    "upper-bound" : "Upper bound:",
    "concurrency-level" : "Concurrency level:",
    "storage" : "Storage",
    "counter-configuration" : "Configuration",
    "no-counters-status" : "No counters yet",
    "no-counters-body" : "Create counters with the CLI or a remote client.",
    "tasks-table-label" : "Tasks",
    "task-name" : "Name",
    "task-type" : "Type",
    "context-name" : "Context name",
    "operation-name" : "Operation name",
    "parameters" : "Parameters",
    "allowed-role" : "Allowed role",
    "allowed-role-null" : "-",
    "no-tasks-status" : "No tasks yet",
    "no-tasks-body" : "Create tasks with the CLI or a remote client.",
    "rebalancing": {
      "disabled-status" : "Cluster rebalancing off",
      "enabled": "Cluster rebalancing on",
      "disabled": "Cluster rebalancing off",
      "modal-disable-title" : "Disable cluster rebalancing",
      "modal-disable-button" : "Turn off rebalancing",
      "modal-enable-title" : "Enable cluster rebalancing",
      "modal-enable-button" : "Turn on rebalancing",
      "modal-cancel-button" : "Cancel",
      "modal-description" : "Temporarily disable only to avoid repeated cluster rebalancing operations when restarting a node or adding multiple nodes. Always enable cluster rebalancing as soon as possible to prevent data loss."
    }
  },
  "caches" : {
    "create" : {
      "page-title" : "Create a cache in {{cmName}}",
      "page-title-with-backups": "Create a cache in {{cmName}} on site {{localsite}}",
      "cache-name": "Cache name",
      "cache-name-help" : "Enter a unique name for your cache.",
      "cache-name-help-invalid" : "You must specify a unique name for each cache.",
      "configuration": "Cache configuration in XML, JSON, or YAML format",
      "configuration-help" : "Enter valid cache configuration.",
      "configuration-info" : "Use the distributed cache for demonstration purposes.",
      "cache-configuration-docs" : "Need help? See \"Configuring caches\" in the documentation.",
      "configuration-help-invalid" : "Cache configuration must be valid and conform to the schema.",
      "configuration-provide" : "Provide cache configuration",
      "templates": "Cache templates",
      "templates-help" : "Create caches from a custom template.",
      "templates-placeholder" : "Select a cache template",
      "create-button-label": "Create",
      "next-button-label": "Next",
      "back-button-label": "Back",
      "cancel-button-label": "Cancel",
      "download-button-label": "Download {{format}}",
      "getting-started": {
        "nav-title": "Get started",
        "cache-name-title": "Enter a cache name",
        "cache-name-label": "Give your cache a unique name",
        "cache-name-label-invalid": "You must specify a cache name that does not already exist.",
        "cache-create-title": "Select a way to create your cache",
        "cache-create-builder": "Build cache configuration",
        "cache-create-builder-help": "Follow a series of prompts to create a cache.",
        "cache-create-add": "Add cache configuration",
        "cache-create-add-help": "Provide cache configuration in XML, JSON, or YAML format."
      },
      "edit-config":{
        "nav-title": "Add configuration",
        "page-title": "Provide your cache configuration",
        "cache-config": "Enter valid XML, JSON, or YAML",
        "cache-config-invalid": "Configuration must conform to the schema.",
        "demo-cache": "Use the distributed cache for demonstration purposes.",
        "template-help-invalid": "Select a template or enter a configuration"
      },
      "configurations":{
        "nav-title": "Build configuration",
        "basic":{
          "nav-title": "Basic options",
          "mode-title": "Choose a cache mode",
          "mode-tooltip": "Clustered caches can be distributed or replicated. Distributed caches offer linear scalability and efficient memory usage. Replicated caches offer data guarantees and fault tolerance.",
          "mode-distributed": "Distributed",
          "mode-replicated": "Replicated",
          "cluster-repl-title": "Configure cluster replication",
          "cluster-repl-tooltip": "Clusters can replicate data between nodes using synchronous or asynchronous communication. Synchronous replication provides consistency but can slow down write operations. Asynchronous replications gives you better throughput for write operations but can lead to inconsistency and data loss.",
          "cluster-repl-async": "Asynchronous",
          "cluster-repl-sync": "Synchronous",
          "number-owners": "Set the number of owners",
          "number-owners-tooltip": "Controls how many copies of each entry should exist in a distributed cache. Maintaining more replicas of each entry reduces the risk of data loss but also reduces overall capacity. The number of nodes for a distributed cache should always be at least one more than the number of owners.",
          "statistics-title": "Statistics",
          "statistics-tooltip": "Enable statistics for your cache.",
          "encoding-cache-title": "Select an encoding",
          "encoding-cache-tooltip": "Choose a media type that describes data that you store in the cache. Use ProtoStream encoding for optimal performance and interoperability between client applications.",
          "expiration-title": "Expiration",
          "expiration-tooltip": "Limit the amount of time that entries can remain in the cache. Expiration takes place across the cluster and removes entries based on a lifespan or maximum idle time.",
          "lifespan": "Lifespan",
          "lifespan-tooltip": "Set the amount of time that entries can remain in the cache after creation. If you set the lifespan value to -1, entries never expire.",
          "lifespan-helper-invalid": "The minimum value is -1.",
          "max-idle": "Maximum idle",
          "max-idle-tooltip": "Set the amount of time that entries can remain in the cache after last access. If you set the maximum idle value to -1, entries never expire.",
          "max-idle-helper-invalid": "The minimum value is -1."
        },
        "feature": {
          "transactional-disabled": "Transactional caches are available in synchronous replication mode only.",
          "backups-disabled": "Backups are available only when you configure {{brandname}} to perform cross-site replication.",
          "secured-disabled": "You must enable authentication and authorization in {{brandname}} Server to configure security.",
          "nav-title": "{{brandname}} capabilities",
          "cache-feature-list": "Add {{brandname}} capabilities",
          "cache-feature-list-tooltip": "Add capabilities to your cache.",
          "cache-feature-list-placeholder": "Select capabilities",
          "cache-feature-list-typeahead": "Select capabilities",
          "bounded": "Bounded",
          "bounded-tooltip": "Control the size of the cache by configuring {{brandname}} to evict entries. You can configure an eviction threshold based on the maximum amount of memory that a cache can use or based on the total number of entries that a cache can hold.",
          "radio-max-size": "Maximum amount of memory",
          "radio-max-count": "Total number of entries",
          "max-size": "Maximum amount of memory",
          "max-size-tooltip": "Configure a maximum size for the cache. When the cache reaches this threshold, {{brandname}} removes entries according to the eviction strategy that you configure.",
          "max-size-helper-invalid": "You must specify a positive number as the maximum size for the cache.",
          "max-count": "Total number of entries",
          "max-count-tooltip": "Configure the total number of entries that the cache can contain. When the cache reaches this threshold, {{brandname}} removes entries according to the eviction strategy that you configure.",
          "max-count-helper-invalid": "You must specify a positive number as the total number of entries.",
          "eviction-strategy": "Eviction strategy",
          "eviction-strategy-tooltip": "Specify how {{brandname}} removes entries when the cache reaches the threshold that you configure. The REMOVE strategy evicts older entries to make space for new ones. The EXCEPTION strategy configures {{brandname}} to log an exception and prevent new entries from being created.",
          "indexed": "Indexing",
          "indexed-tooltip": "Build an index of values in the cache for faster queries and full-text search capabilities.",
          "index-storage": "Index storage",
          "index-storage-tooltip": "Configure how {{brandname}} stores indexes. Persistent storage saves the index on the host file system so the index is available between restarts. Volatile storage saves the index in JVM heap memory, which means that the index does not survive restarts. You should configure volatile index storage only for small datasets.",
          "index-storage-persistent": "Persistent",
          "index-storage-volatile": "Volatile",
          "index-storage-entity": "Entities to index",
          "index-storage-add-btn": "Add",
          "index-storage-entity-tooltip": "Specify the fully qualified class names of the entities you want {{brandname}} to include when building the index.",
          "index-storage-entity-helper": "Each entity that you specify must be unique.",
          "secured": "Security authorization",
          "secured-description": "Restrict access to the cache to protect data. {{brandname}} denies cache operations if users do not have one of the roles you select.",
          "select-roles": "Select roles",
          "backups": "Backups for {{local_site_name}}",
          "backups-description": "Configure {{brandname}} to replicate data in the cache of cluster {{localsite}} to another cluster.",
          "backups-site": "Backup locations",
          "backups-site-tooltip": "Select one or more remote sites to which {{brandname}} backs up data in the cache.",
          "select-sites": "Select sites",
          "backups-setting": "Asynchronous backup settings",
          "merge-policy": "Merge policy",
          "merge-policy-tooltip": "Specify how {{brandname}} resolves conflicting entries between backup locations when using the ASYNC strategy. You can specify one of the default merge policies or the fully qualified name of a class that implements the XSiteEntryMergePolicy interface.",
          "max-cleanup-delay": "Maximum cleanup delay",
          "max-cleanup-delay-tooltip": "Specify the maximum delay, in milliseconds, between which tombstone cleanup tasks run when using the ASYNC strategy.",
          "tombstone-map-site": "Number of tombstones",
          "tombstone-map-site-tooltip": "Specify the target number of tombstones, or key metadata, to store when using the ASYNC strategy. If the number of tombstones increases beyond this number then {{brandname}} runs the cleanup task more frequently. Likewise, if the number of tombstones is less than this number then {{brandname}} does not run the cleanup task as frequently.",
          "backup-for": "This cache receives updates from cache with a different name",
          "backup-for-tooltip": "Infinispan replicates data between caches that have the same name by default. Enable this option to specify the name and the location of the cache that will send data into this cache.",
          "remote-cache": "Cache name",
          "remote-cache-tooltip": "Specify the name of the cache on the remote site if it is different to the cache you are creating. {{brandname}} replicates data between caches that have the same name by default.",
          "remote-site": "Remote site",
          "remote-site-tooltip": "Specify the name of the remote site where the backup cache is located, for example LON or NYC.",
          "strategy": "Backup strategy",
          "strategy-tooltip": "Configure how {{brandname}} replicates data to the remote site. Synchronous backups offer the strongest guarantee of data consistency but add latency, which reduces performance. Asynchronous backups have lower consistency guarantees but higher performance.",
          "strategy-async": "ASYNC",
          "strategy-sync": "SYNC",
          "two-phase-commit": "Two-phase commit",
          "two-phase-commit-tooltip": "Enable two-phase commits for optimistic transactional caches with the SYNC backup strategy.",
          "failure-policy": "Failure policy",
          "failure-policy-tooltip": "Select a failure policy that handles local writes to the cache if synchronous backup operations fail. IGNORE writes to the local cache and ignores the failed backup. WARN logs an exception and writes to the local cache. FAIL throws an exception and attempts to stop the write to the local cache. CUSTOM uses a custom implementation that you specify in the failure policy class field.",
          "timeout": "Timeout",
          "timeout-tooltip": "Specify the timeout, in milliseconds, for synchronous and asynchronous backup operations.",
          "failure-policy-class": "Failure policy class",
          "failure-policy-class-tooltip": "Specify the fully qualified name of a class that implements the CustomFailurePolicy interface if you select CUSTOM as the failure policy.",
          "take-offline": "Take offline",
          "take-offline-tooltip": "Operations to replicate data across clusters are resource intensive. To excessive resource usage {{brandname}} can take backup locations offline automatically.",
          "after-failure": "After failures",
          "after-failure-tooltip": "Set the number of consecutive failures that can occur for backup operations before sites go offline. Specify a negative or zero value to use minimum wait time only.",
          "min-wait": "Minimum wait",
          "min-wait-tooltip": "Set the minimum time to wait, in milliseconds, before sites go offline when backup operations fail. If subsequent operations are successful, the minimum wait time is reset. If you set 'after-failures', sites go offline when the wait time is reached and the number of failures occur. One or two minutes is generally a suitable time to wait before automatically taking backup locations offline. If the wait period is too short then backup locations go offline too soon. You then need to bring clusters back online and perform state transfer operations to ensure data is in sync between the clusters.",
          "state-transfer": "State transfer",
          "state-transfer-tooltip": "Modify state transfer operations that synchronize data between sites.",
          "chunk-size": "Chunk size",
          "chunk-size-tooltip": "Specify how many cache entries are batched in each transfer request.",
          "timeout-state-transfer": "Timeout",
          "timeout-state-transfer-tooltip": "Specify the time to wait, in milliseconds, for the backup site acknowledge the state chunk received and applied. The default value is 20 minutes.",
          "max-retries": "Maximum retries",
          "max-retries-tooltip": "Set the maximum number of retry attempts for push state failures. Specify a value of 0 (zero) to disable retry attempts. The default value is 30.",
          "wait-time": "Wait time",
          "wait-time-tooltip": "Set the amount of time, in milliseconds, to wait between retry attempts for push state failures. You must specify a value of 1 or more. The default value is 2000.",
          "mode": "State transfer mode",
          "mode-tooltip": "Control whether state transfer happens manually on user action, which is the default, or automatically when backup locations come online. {{brandname}} can perform automatic state transfer with the ASYNC backup strategy only.",
          "mode-manual": "MANUAL",
          "mode-auto": "AUTOMATIC",
          "transactional": "Transactions",
          "transactional-description": "Configure {{brandname}} to participate in JTA-compliant distributed transactions.",
          "transactional-mode": "Transaction mode",
          "transactional-mode-tooltip": "Configure the mode that {{brandname}} uses when carrying out transactions to ensure the cache state is consistent.",
          "non-xa": "NON_XA",
          "non-xa-tooltip": "{{brandname}} enlists the cache with the Java transaction manager through the Synchronization API. This means that {{brandname}} does not participate in transactions but receives notifications about the transaction lifecycle. You should use the NON_XA mode when there is an external system that handles transactions, for example when {{brandname}} provides a second-level (2LC) cache.",
          "non-durable-xa": "NON_DURABLE_XA",
          "non-durable-xa-tooltip": "{{brandname}} disables transaction recovery and enlists the cache with the Java transaction manager through the XAResource API. Disabling recovery means that you cannot recover failed transactions but do not have the performance overhead of handling in-doubt transactions.",
          "full-xa": "FULL_XA",
          "full-xa-tooltip": "{{brandname}} uses transaction recovery and enlists the cache with the Java transaction manager through the XAResource API. Using recovery provides durability by marking transactions as in-doubt when they fail. FULL_XA can impact performance by reducing cluster capacity when storing in-doubt transactions and by increasing traffic for failed transaction notifications.",
          "locking-mode": "Locking mode",
          "locking-mode-tooltip": "Configure how {{brandname}} locks keys to perform write operations for transactions. Locking keys adds contention that increases latency for write operations. You can adjust the amount of contention by using optimistic or pessimistic locking.",
          "locking-mode-optimistic": "Optimistic",
          "locking-mode-optimistic-tooltip": "{{brandname}} locks keys when it invokes the commit() method. Keys are locked for shorter periods of time which reduces overall latency but makes transaction recovery less efficient.",
          "locking-mode-pessimistic": "Pessimistic",
          "locking-mode-pessimistic-tooltip": "{{brandname}} locks keys when it invokes the put() method. Keys are locked for longer periods of time which increases latency but makes transaction recovery more efficient.",
          "persistent": "Persistence",
          "persistent-description": "Add non-volatile storage so data remains available after cluster restarts. You can also load caches from persistent storage and use {{brandname}} for high performance data access.",
          "persistent-error": "Persistent storage configuration must be in JSON format and conform to the {{brandname}} schema.",
          "persistent-hint": "The provided configuration is an example template that you should modify for your environment.",
          "persistent-hint-link": "Need help? See \"Configuring persistent storage\" in the documentation.",
          "passivation": "Passivation",
          "passivation-tooltip": "Enable passivation to keep only frequently used data in the cache. {{brandname}} writes entries to persistent storage when it evicts those entries from memory.",
          "connection-attempts": "Connection attempts",
          "connection-attempts-tooltip": "Specify how many times {{brandname}} should try to connect to the cache store. The default value is 10.",
          "connection-interval": "Connection interval",
          "connection-interval-tooltip": "Set the interval, in milliseconds, between connection attempts. The default value is 50.",
          "availability-interval": "Availability interval",
          "availability-interval-tooltip": "Set the interval, in milliseconds, between which {{brandname}} polls the cache store to ensure it is available. The default value is 1000.",
          "storages": "Storage configuration",
          "storages-tooltip": "Select a cache store that configures {{brandname}} to interact with a persistent data source.",
          "storage-placeholder": "Choose a cache store",
          "file-store-description": "Use the local host filesystem for persistent storage. For clustered caches, file-based cache stores are unique to each {{brandname}} node.",
          "remote-store-description": "Use a cache on another {{brandname}} cluster for persistent storage. Remote stores connect through the Hot Rod endpoint and are required to perform rolling upgrades for {{brandname}} clusters.",
          "jdbc-store-description": "Use a relational database for persistent storage through a JDBC connection. You must ensure that the appropriate JDBC driver is available to the {{brandname}} cluster.",
          "table-sql-store-description": "Load entries from a single database table to your {{brandname}} cache. You must ensure that the appropriate JDBC driver is available to the {{brandname}} cluster.",
          "query-sql-store-description": "Perform SQL queries to load entries from one or more database tables, including sub-columns. You can also perform insert, update, and delete operations. You must ensure that the appropriate JDBC driver is available to the {{brandname}} cluster.",
          "rocks-db-description": "Use RocksDB as a cache store. A RocksDB cache store uses two databases; one as a primary store and another to hold expired entries.",
          "custom-description": "Use a custom cache store that you implement with the {{brandname}} Persistence SPI."
        },
        "advanced-options": {
          "nav-title": "Cache tuning",
          "storage-title": "Choose a storage type",
          "storage-tooltip": "Caches can store data in JVM heap memory or in off-heap memory. JVM heap is a managed memory space. Off-heap storage is native system memory outside JVM memory management. Off-heap storage uses less memory per entry compared with JVM heap storage and can improve performance by avoiding avoids garbage collection (GC) runs.",
          "radio-heap": "Heap",
          "radio-off-heap": "Off-heap",
          "locking-title": "Adjust locking for concurrent access",
          "locking-tooltip": "Configure locking and concurrency to control read and write access to data.",
          "concurrency-level-title": "Concurrency level",
          "concurrency-level-tooltip": "Configures the number of locks to create in the shared pool for lock striping.",
          "isolation-level-title": "Read isolation level",
          "isolation-level-tooltip": "Read isolation levels guarantee whether or not data in the cache has changed during a transaction.",
          "isolation-level-repeatable-read": "REPEATABLE_READ",
          "isolation-level-repeatable-read-tooltip": "Read operations return the same value that {{brandname}} initially retrieves for an entry during a transaction. This is the default read isolation level because it guarantees consistency.",
          "isolation-level-read-committed": "READ_COMMITTED",
          "isolation-level-read-committed-tooltip": "Read operations might return different values if another transaction modifies the entries.",
          "lock-acquisition-timeout-title": "Lock timeout",
          "lock-acquisition-timeout-tooltip": "Sets how many milliseconds to wait for lock acquisition.",
          "striping": "Lock striping",
          "striping-tooltip": "Uses a shared pool of locks for all entries in the cache. Striping lowers the memory footprint for locks but can reduce concurrency. If you disable striping, a lock is created for each entry in the cache.",
          "index-tuning": "Index tuning",
          "index-tuning-tooltip": "Control how {{brandname}} interacts with an index to optimize performance.",
          "index-reader": "Index reader",
          "refresh-interval": "Refresh interval",
          "refresh-interval-tooltip": "Set the interval, in milliseconds, to refresh the index reader so that search results are up to date.",
          "index-writer": "Index writer",
          "low-level-trace": "Low-level trace",
          "low-level-trace-tooltip": "Enable low-level trace information for indexing operations. Enabling this attribute substantially degrades performance. You should use low-level tracing only as a last resource for troubleshooting.",
          "commit-interval": "Commit interval",
          "commit-interval-tooltip": "Set the amount of time, in milliseconds, that index changes buffered in memory are flushed to index storage. The index commit has a performance cost so you should not set a low value.",
          "max-buffered-entries": "Maximum buffered entries",
          "max-buffered-entries-tooltip": "Set the maximum number of entries that can be buffered in-memory before they are flushed to index storage. Large values result in faster indexing but use more memory. When used in combination with the ram-buffer-size attribute, a flush occurs for whichever event happens first.",
          "queue-count": "Queue count",
          "queue-count-tooltip": "Set the number of internal queues to use for each indexed type. Each queue holds a batch of modifications that is applied to the index and queues are processed in parallel.",
          "queue-size": "Queue size",
          "queue-size-tooltip": "Set the maximum number of elements each queue can hold. Increasing the queue-size value increases the amount of memory that is used during indexing operations. Setting a value that is too small can block indexing operations.",
          "ram-buffer-size": "RAM buffer size",
          "ram-buffer-size-tooltip": "Set the maximum amount of memory that can be used for buffering added entries and deletions before they are flushed to the index storage.",
          "thread-pool-size": "Thread pool size",
          "thread-pool-size-tooltip": "Specify the number of threads that execute write operations to the index.",
          "index-merge": "Index merge",
          "calibrate-by-deletes": "Calibrate by deletes",
          "calibrate-by-deletes-tooltip": "Includes the the number of deleted entries in an index when counting the entries in the segment. Disabling results in more frequent merges caused by max-entries, but will more aggressively merge segments with many deleted documents, improving query performance.",
          "factor": "Factor",
          "factor-tooltip": "Sets the number of segments that are merged at once. With smaller values, merging happens more often, which uses more resources, but the total number of segments will be lower on average, increasing query performance.",
          "max-entries": "Maximum entries",
          "max-entries-tooltip": "Sets the maximum number of entries that an index segment can have before merging. Segments with more than this number of entries are not merged. Smaller values perform better on frequently changing indexes, larger values provide better search performance if the index does not change often.",
          "min-size": "Minimum segment size",
          "min-size-tooltip": "Sets the minimum target size of segments, in MB, for background merges. Segments smaller than this size are merged more aggressively. Setting a value that is too large might result in expensive merge operations, even though they are less frequent.",
          "max-size": "Maximum segment size",
          "max-size-tooltip": "Sets the maximum size of segments, in MB, for background merges. Segments larger than this size are never merged in the background. Settings this to a lower value helps reduce memory requirements and avoids some merging operations at the cost of optimal search speed. ",
          "max-forced-size": "Maximum forced size",
          "max-forced-size-tooltip": "Sets the maximum size of segments, in MB, for forced merges and overrides the max-size attribute. Set this to the same value as max-size or lower. Setting the value too low degrades query performance because documents are deleted.",
          "backups-tuning": "Adjust settings for cache backups",
          "backups-tuning-tooltip": "Configure cross-site replication settings for backup locations.",
          "stop-timeout": "Stop timeout",
          "stop-timeout-tooltip": "Sets the amount of time, in milliseconds, that {{brandname}} waits for ongoing transactions when the cache is stopped.",
          "transaction-manager-lookup": "Transaction manager lookup",
          "transaction-manager-lookup-tooltip": "Specifies a lookup class that returns the TransactionManager to initialize.",
          "complete-timeout": "Complete timeout",
          "complete-timeout-tooltip": "Sets the maximum amount of time, in milliseconds, that transactions can run. {{brandname}} aborts transactions that do not complete before reaching the timeout.",
          "reaper-interval": "Reaper interval",
          "reaper-interval-tooltip": "Sets the amount of time, in milliseconds, between which {{brandname}} checks if transactions are complete.",
          "recovery-cache": "Recovery cache",
          "recovery-cache-tooltip": "Specifies the cache that stores information to recover in-doubt transactions.",
          "transactional-tuning": "Transaction tuning",
          "transactional-tuning-tooltip": "Configures settings for transactional caches."
        }
      },
      "review": {
        "nav-title": "Review configuration",
        "review-title": "Confirm your cache",
        "review-subtitle": "Check the configuration for your cache before you create it. You can go back or start over if you need to make changes.",
        "review-cache-name": "Cache name:"
      }
    },
    "configuration" : {
      "title" : "Available cache templates",
      "page-title" : "Cache templates",
      "no-templates-body" : "Add cache templates to the server configuration.",
      "table-label" : "Create caches from custom templates.",
      "no-encoding-warning" : "This cache either has no encoding configuration or uses an encoding that the console does not support. You must use Hot Rod clients to perform read and write operations on this cache.",
      "no-encoding-docs" : "See \"Cache Encoding and Marshalling\" in the documentation."
    },
    "tabs": {
      "entries": "Entries",
      "entries-size": "Entries ({{size}})",
      "configuration": "Configuration",
      "metrics": "Metrics ({{status}})",
      "metrics-enabled": "Metrics (Enabled)",
      "metrics-disabled": "Metrics (Not enabled)",
      "entries-manage": "Manage entries",
      "query-values":"Query values"
    },
    "info" : {
      "breadcrumb" : "Detail of cache {{cacheName}}",
      "loading" : "Loading cache {{cacheName}} ...",
      "error" : "An error occurred while loading {{cacheName}}"
    },
    "actions" : {
      "action-see-less" : "See fewer cache details",
      "action-see-more" : "See more cache details",
      "action-manage-indexes" : "Manage indexes"
    },
    "entries" : {
      "action-edit" : "Edit",
      "action-delete" : "Delete",
      "action-enter" : "Enter",
      "column-key" : "Key",
      "column-value" : "Value",
      "column-lifespan" : "Time to live",
      "column-maxidle" : "Max idle",
      "column-expires" : "Expires",
      "column-created" : "Created",
      "column-modified" : "Modified",
      "column-lastused" : "Last used",
      "lifespan-immortal" : "Forever",
      "maxidle-immortal" : "Forever",
      "never-expire" : "Never",
      "get-entry-label" : "Retrieve by key text field",
      "get-entry-text" : "Retrieve by key ",
      "get-entry-not-found" : "Cannot retrieve entry with key:",
      "empty-cache" : "The cache is empty",
      "get-entry-button-label" : "Query input button",
      "add-entry-button-label" : "Add entry",
      "clear-entry-button-label" : "Clear all entries",
      "entries-table-label" : "Entries",
      "modal-clear-title" : "Permanently clear all entries?",
      "modal-clear-label" : "Clear all entries modal",
      "modal-clear-button-click" : "Clear",
      "modal-button-delete" : "Delete",
      "modal-button-cancel" : "Cancel",
      "modal-delete-label" : "Delete entry modal",
      "modal-clear-body-line-one" : "This action will permanently clear all entries in",
      "modal-clear-body-line-two" : "This cannot be undone.",
      "modal-delete-body-line-one" : "This action will permanently delete the key",
      "modal-delete-body-line-two" : "from the cache",
      "modal-delete-body-line-three" : "You can always recreate the entry after.",
      "add-entry-key-invalid" : "Key is required",
      "add-entry-key-help" : "",
      "add-entry-key-validated" : "default",
      "add-entry-value-invalid" : "Value is required",
      "add-entry-value-help" : "",
      "add-entry-value-validated" : "default",
      "add-entry-content-type-help" : "Select content type.",
      "add-entry-maxidle-invalid" : "The maximum idle value must be a number",
      "add-entry-maxidle-help" : "If you set a negative value, the entry is never deleted.",
      "add-entry-maxidle-validated" : "default",
      "add-entry-lifespan-invalid" : "Time to live must be a number.",
      "add-entry-lifespan-help" : "If you set a negative value, the entry is never deleted.",
      "add-entry-lifespan-validated" : "default",
      "add-entry-flags-help" : "Select flags",
      "add-entry-form-cache-name" : "Cache name",
      "add-entry-form-key" : "Key",
      "add-entry-form-key-tooltip": "The key can contain JSON or Protobuf values, depending on cache encoding.",
      "add-entry-form-value" : "Value",
      "add-entry-form-value-tooltip": "The value can contain JSON or Protobuf values, depending on cache encoding.",
      "add-entry-form-lifespan": "Time to live (number of seconds)",
      "add-entry-form-lifespan-tooltip": "Sets the number of seconds before",
      "add-entry-form-maxidle": "Maximum idle time (number of seconds)",
      "add-entry-form-maxidle-tooltip": "Sets the number of seconds that entries can be idle.",
      "add-entry-form-options": "Advanced options",
      "add-entry-form-flags": "Flags",
      "add-entry-form-flags-help": "For more information, see 'org.infinispan.context.Flag'.",
      "add-entry-form-flags-label": "Select Flags",
      "add-entry-form-key-type-label": "Key content type",
      "add-entry-form-key-type": "Key content type",
      "add-entry-form-key-type-select": "Select a key content type",
      "add-entry-form-key-type-select-label": "Select Key Content Type",
      "add-entry-form-value-type-label": "Value content type",
      "add-entry-form-value-type-invalid": "Value content type is required",
      "add-entry-form-value-type-select": "Select a value content type",
      "add-entry-form-value-type-select-label": "Select Value Content Type"
    },
    "query" : {
      "button-clear-query-stats" : "Clear all stats",
      "stat-max" : "Max",
      "stat-count" : "Count",
      "stat-average" : "Average",
      "stat-slowest" : "Slowest",
      "modal-clear-query-stats" : "Permanently clear query stats?",
      "modal-clear-query-stats-label" : "Clear query stats modal",
      "modal-button-query-clear-stats" : "Clear stats",
      "modal-button-cancel" : "Cancel",
      "modal-button-query-clear-stats-body" : "All query statistics in this cluster will be removed."
    },
    "index" : {
      "title" : "Index management",
      "empty" : "Indexes are empty",
      "class-name" : "Class name",
      "entities-number" : "Number of entities",
      "size" : "Index size in bytes",
      "indexing-status" : "Indexing",
      "button-clear" : "Clear index",
      "button-rebuild" : "Rebuild index",
      "button-back-to-cache-detail" : "Back"
    },
    "rebalancing": {
      "rebalancing" : "Rebalancing",
      "rebalanced" : "Rebalanced",
      "enabled" : "Rebalancing is on",
      "disabled" : "Rebalancing is off",
      "modal-disable-title" : "Disable rebalancing on this cache?",
      "modal-disable-button" : "Disable",
      "modal-enable-title" : "Enable rebalancing on this cache?",
      "modal-enable-button" : "Enable",
      "modal-cancel-button" : "Cancel",
      "modal-description" : " Disabling rebalancing prevents the cluster from repairing data in this cache belonging to nodes leaving the cluster. It should be re-enabled as soon as possible to prevent possible data-loss in this cache."
    },
    "availability": {
      "modal-available-title": "Make cache available",
      "modal-available-description": "will become available for read and write operations.",
      "modal-available-button-done": "OK",
      "modal-available-button-cancel": "Cancel"
    },
    "cache-metrics":{
      "entries-title":"Entries",
      "memory-title":"Memory",
      "performance-title":"Performance",
      "data-access-title":"Data access",
      "data-access-expanded":"Show more information",
      "data-access-collapsed":"Show less information",
      "average-reads":"Average cache read time",
      "average-writes":"Average cache write time",
      "average-deletes":"Average cache delete time",
      "average-reads-tooltip":"Average time, in milliseconds, for read operations to complete.",
      "average-writes-tooltip":"Average time, in milliseconds, for write operations to complete.",
      "average-deletes-tooltip":"Average time, in milliseconds, for delete operations to complete.",
      "data-access-hits-info":"Hits displays the number of successful requests for cache entries.",
      "data-access-misses-info":"Misses displays the number of times that a client requested an entry that was not in the cache. Misses occur when an entry is never stored in the cache or after an entry is evicted from the cache.",
      "data-access-stores-info":"Stores displays the number of write operations that put entries in the cache.",
      "data-access-retrievals-info":"Retrievals displays the number of read operations that get entries from the cache.",
      "data-access-remove-hits-info":"Remove hits displays the number of successful requests to delete cache entries.",
      "data-access-remove-misses-info":"Remove misses displays the number of times that a client attempted to delete an entry that was not in the cache.",
      "data-access-evictions-info":"Evictions displays the number of entries that have been evicted from the cache. Eviction removes entries from the cache when it reaches a configured threshold.",
      "current-number-entries":"Current number of entries",
      "current-number-entries-tooltip":"Displays the number of entries that are stored in the cache. Each entry is counted only once so the number does not include replicas.",
      "min-nodes":"Minimum number of nodes",
      "min-nodes-tooltip":"Displays the number of nodes that must remain in the cluster to avoid data loss.",
      "cache-size-off-heap":"Size of cache in off-heap memory",
      "cache-size-off-heap-tooltip":"Displays the amount of off-heap memory that data in the cache uses. Total memory usage is higher because it includes internal data structures.",
      "cache-size-heap":"Size of cache in heap memory",
      "cache-size-heap-tooltip":"Displays the amount of JVM heap memory that data in the cache uses. Total memory usage is higher because it includes internal data structures."
    }
  }
}
